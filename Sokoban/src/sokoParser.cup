package Generated; 

import java.util.*;

import java_cup.runtime.*;
import source.SokoPieces.*;
import source.AzioneFor;
import source.AzioneIf;
import source.AzionePiazzamento;
import source.SokoPieces;
import source.ListaAzioni;
import source.TipoPiazzamento;
import source.TipoCondizione;
import source.Condizione;
import source.intVar;
import source.strVar;
import source.element;
import source.Azione;
import source.MapAndResult;
import source.Result;
import source.Assegnazione;


parser code
{:
	public static int syntax_error = 0;
	public static int semantic_error = 0;

	public void syntax_error(Symbol sym) {
		StringBuffer m = new StringBuffer("Syntax Error");

		if (sym.left != -1) {
			m.append(" (line " + (sym.left+1));   
			m.append(", column " + (sym.right+1) + ") ");
		}
		System.err.print(m);
	}

	public void report_error(String message, Object info) {
		StringBuffer m = new StringBuffer("Error");
		m.append(" : " + message);
		if (info != null) {
			m.append(" (line " + (((java_cup.runtime.Symbol) info).left + 1) + ")");
		}
		System.err.println(m);
	}
	
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}
:}

action code
{:
	Map<String, Integer> varMap = new HashMap<String, Integer>();
	
	SokoPieces[][] mappa=null;
	
	int SemanticErrorNumber=0;
	boolean error=false;
	//ArrayList<ListaAzioni> listaAzioniTot=new ArrayList<ListaAzioni>();

:}


terminal 	VAR, HEIGHT, WIDTH, FOR, IF, END, DIM, NMOB, MOB, FISSI, GOAL, SOKO, UGUALE,UGUALEUGUALE, MINUG, MAGUG,MIN, MAG, INCR, DECR, DIVERSO, 			TO, TC, INT, ID, VIR, PV;

non terminal 	map, part, def, elemento, altezza, larghezza, corpo, definizioni,  definizione, dichiar, numBlocchi, dimBlocchi,
		cicloFor, contenuto, assegnazione, termine, segno, avanzamento, piazzamento, tipo, coppia, coordinata, sezioneIF;

start with map;

 
map 	::= 	definizioni dichiar part {:System.out.println("map"); :}| 
		dichiar part 
		{:System.out.println("map"); :} /*|
		error {: parser.report_error("map errore",null); :}*/;
 
dichiar	::=	dimBlocchi numBlocchi {:System.out.println("dichiar1__"); :}| 		// #Dimensioni h=height, w=width;
		numBlocchi dimBlocchi {:System.out.println("dichiar2__"); :};		// #BlocchiMobili 5;

dimBlocchi ::= 	DIM altezza VIR larghezza PV {:System.out.println("dimBlocchi__"); :}|
		DIM larghezza VIR altezza PV {:System.out.println("dimBlocchi__"); :};
altezza	::=	HEIGHT UGUALE INT |
		HEIGHT UGUALE ID ;
larghezza ::=	WIDTH UGUALE INT |
		WIDTH UGUALE ID ;
		

numBlocchi ::=	NMOB INT PV ;

definizioni ::=	elemento |
		definizioni elemento {:System.out.println("definizioni__"); :}/* |
		error {: parser.report_error("defini errore",null); :}*/;

elemento ::= 	VAR def PV ;	// definizioni di varabili

def	::=	def VIR definizione |
		definizione /*|
		error {: parser.report_error("def errore",null); :}*/;

definizione ::= ID UGUALE INT {:System.out.println("definizione1__"); :}|
		ID UGUALE ID {:System.out.println("definizione2__"); :}|
		ID {:System.out.println("definizione3__"); :};

part	::=	corpo |
		elemento | 
		part elemento |
		part corpo /*|
		part error {: parser.report_error("part errore",null); :}*/;

corpo 	::=	cicloFor {:System.out.println("corpo__"); :}|
		piazzamento:p 
		{: 
			AzionePiazzamento ap=(AzionePiazzamento)p;
			MapAndResult mar=ap.eseguiAzione(varMap, mappa);
			if (mar.result!=Result.OK){
				parser.report_error(mar.result.name(),null);
				SemanticErrorNumber++;
				error=true;
			}
			if(!error)
				mappa=mar.mappa;
			error=false;
		:}|
		sezioneIF {:System.out.println("corpo__"); :}/*|
		error {: parser.report_error("corpo errore",null); :}*/;

cicloFor ::=	FOR TO assegnazione:as PV termine:t PV avanzamento:av TC contenuto:c END FOR PV 
				{:
					AzioneFor azione=new AzioneFor();
					azione.var=((Assegnazione)as).id1;
					azione.start=element.traduci(((Assegnazione)as).id2, varMap);
					azione.cond=(Condizione)t;
					azione.incremento=(Boolean)av;
					azione.la=(ListaAzioni)c;
					RESULT = azione;
				:}/*|
				FOR error {: parser.report_error("for errore",null); :}*/;
				
assegnazione::=	ID:id1 UGUALE ID:id2 
				{:
					RESULT=new Assegnazione(id1, id2);
				:} |
				ID:id1 UGUALE INT:id2
				{:
					RESULT=new Assegnazione(id1, id2);
				:};

termine	::=	ID:id1 segno:s ID:id2
			{:
				if(!varMap.containsKey((String)id1)){
					parser.report_error(Result.UndefinedVariable.name(),null);
					SemanticErrorNumber++;
					error=true;
				}
				if(!varMap.containsKey((String)id2)){
					parser.report_error(Result.UndefinedVariable.name(),null);
					SemanticErrorNumber++;
					error=true;
				}
				if(!error)
					RESULT=new Condizione(id1,id2,s);
				error=false;
				RESULT=null;
			:}|
			ID:id1 segno:s INT:id2 
			{:
				if(!varMap.containsKey((String)id1)){
					parser.report_error(Result.UndefinedVariable.name(),null);
					SemanticErrorNumber++;
					error=true;
				}
				if(!error)
					RESULT=new Condizione(id1,id2,s);
				error=false;
				RESULT=null;
			:};

segno	::=	UGUALEUGUALE:s {: RESULT=s; :}|
			MAGUG :s {: RESULT=s; :}|
			MINUG :s {: RESULT=s; :}|
			MAG :s {: RESULT=s; :}|
			MIN :s {: RESULT=s; :}|
			DIVERSO :s {: RESULT=s; :};
		
avanzamento ::=	ID INCR {: RESULT=new Boolean(true); :}|
				ID DECR {: RESULT=new Boolean(false); :};  		

contenuto ::=	piazzamento:p /*creo lista azioni */
				{:
					RESULT=new ListaAzioni(p);
				:}	| 
				cicloFor:f /*creo lista azioni */
				{:
					RESULT=new ListaAzioni(f);
				:}	|
				sezioneIF :i /*creo lista azioni */
				{:
					RESULT=new ListaAzioni(i);
				:}	|
				contenuto:c piazzamento:p /*aggiungo a lista azioni */
				{:
					((ListaAzioni)c).AddAzione(p);
					RESULT=c;
				:}	|
				contenuto:c sezioneIF:i /*aggiungo a lista azioni */
				{:
					((ListaAzioni)c).AddAzione(i);
					RESULT=c;
				:}	|
				contenuto:c cicloFor:f /*aggiungo a lista azioni */
				{:
					((ListaAzioni)c).AddAzione(f);
					RESULT=c;
				:}	
			/*|
			error {: parser.report_error("contenuto errore",null); :}|
			contenuto error {: parser.report_error("contenuto errore",null); :}*/;

piazzamento ::=	tipo:t1 TO coppia:cp TC PV 
				{:
					((AzionePiazzamento)cp).setType(t1);
					RESULT=cp;
				:} /*| 
				tipo TO coppia TC error {: parser.report_error("piazzamento errore",null); :}|
				tipo error {: parser.report_error("piazzamento errore",null); :}|
				tipo TO error TC PV {: parser.report_error("piazzamento errore",null); :}*/
				;
tipo ::=	MOB:t {: RESULT = t; :} |
			FISSI:t {: RESULT = t; :} |
			GOAL:t {: RESULT = t; :} | 
			SOKO:t {: RESULT = t; :} ;
		
coppia ::=	coordinata:t1 VIR coordinata:t2
			{: 
				RESULT=new AzionePiazzamento(t1,t2);
			:} /*|
			coordinata error 
		 			{: parser.report_fatal_error("coppia errore",null); :}|
			error coordinata 
					{: parser.report_fatal_error("coppia errore",null); :}*/;
					
coordinata ::=	INT:t {: RESULT=t; :} |
		ID:t {: RESULT=t; :};


sezioneIF ::= IF TO termine:t TC contenuto:c END IF PV 
				{:
					if(t!=null){
						ArrayList<Azione> azlist=((ListaAzioni)c).getActions();
						if( ((Condizione)t).valute(varMap) ){
							Iterator<Azione> it=azlist.iterator();
							while(it.hasNext()){
								Azione az = it.next();
								if ( az instanceof AzioneFor){
									;
								}
								if ( az instanceof AzioneIf){
									;
								}
								if ( az instanceof AzionePiazzamento){
									AzionePiazzamento ap=(AzionePiazzamento)az;
									MapAndResult mar=ap.eseguiAzione(varMap, mappa);
									if (mar.result!=Result.OK){
										parser.report_error(mar.result.name(),null);
										SemanticErrorNumber++;
									}
									mappa=mar.mappa;
								}
							}
						}
					}
				:}/*|
				IF error {: parser.report_error("sezione if errore",null); :}*/;








