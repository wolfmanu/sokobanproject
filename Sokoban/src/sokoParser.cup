
package Generated;

import java.util.*;

import java_cup.runtime.*;
import source.SokoPieces.*;
import source.AzioneFor;
import source.AzioneIf;
import source.AzionePiazzamento;
import source.SokoPieces;
import source.ListaAzioni; 
import source.TipoPiazzamento;
import source.TipoCondizione;
import source.Condizione;
import source.intVar;
import source.strVar;
import source.element;
import source.Azione;
import source.MapAndResult;
import source.Result;
import source.Assegnazione;

  
parser code 
{:
	SokoPieces[][] mappa=null;

	public static int syntax_error = 0;
	public static int semantic_error = 0;
	boolean error=false;
	public int blocchiMobili=0;

	public void syntax_error(Symbol sym) {
		StringBuffer m = new StringBuffer("Syntax Error");

		if (sym.left != -1) {
			m.append(" (line " + (sym.left+1));   
			m.append(", column " + (sym.right+1) + ") ");
		}
		System.err.print(m);
	} 

	public void report_error(String message, Object info) {
		StringBuffer m = new StringBuffer("Error");
		m.append(" : " + message);
		if (info != null) {
			m.append(" (line " + (((java_cup.runtime.Symbol) info).left + 1) + ")");
		}
		System.err.println(m);
	}
	
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}
	public SokoPieces[][] getMap(){
		return mappa;
	}
	
	public boolean HasError(){
		return error;
	}
:}

action code
{:
	Map<String, Integer> varMap = new HashMap<String, Integer>();
	
	
	
	int SemanticErrorNumber=0;
	
			
	//ArrayList<ListaAzioni> listaAzioniTot=new ArrayList<ListaAzioni>();

	

:}


terminal 	VAR, HEIGHT, WIDTH, FOR, IF, END, DIM, NMOB, MOB, FISSI, GOAL, SOKO, UGUALE,UGUALEUGUALE, MINUG, MAGUG,MIN, MAG, INCR, DECR, DIVERSO, 			TO, TC, INT, ID, VIR, PV;

non terminal 	myID,map, part, def, elemento, altezza, larghezza, corpo, definizioni,  definizione, dichiar, numBlocchi, dimBlocchi,
		cicloFor, contenuto, assegnazione, termine, segno, avanzamento, piazzamento, tipo, coppia, coordinata, sezioneIF;

start with map;

 
map 	::= 	definizioni dichiar part 
				{:
					if(!parser.error){
						System.out.println("ok terminato");
					}
					else
						System.out.println("NOT OK terminato");
				:}| 
				dichiar part 
				{:
					if(!parser.error){
						System.out.println("ok terminato");
					}
					else
						System.out.println("NOT OK terminato");
				:} /*|
				error {: parser.report_error("map errore",null); :}*/;
 
dichiar	::=	dimBlocchi numBlocchi |// #Dimensioni h=height, w=width;
			numBlocchi dimBlocchi ;		// #BlocchiMobili 5;

dimBlocchi ::= 	DIM altezza:a VIR larghezza:l PV 
				{:
					if (a!= null && l!=null){ 
						int h=((Integer)a).intValue();
						int w=((Integer)l).intValue();
						varMap.put(new String("h"), (Integer)a);
						varMap.put(new String("w"), (Integer)l);
						parser.mappa=new SokoPieces[h][w];
						for(int k=0;k<h;k++)
							for(int j=0;j<w;j++)
								parser.mappa[k][j]=SokoPieces.floor;
						System.out.println("mappa.len="+parser.mappa.length+"-mappa[0].len="+parser.mappa[0].length);
					}
					else{
						parser.report_error("Errore dichiarazione dimensioni",null);
						parser.error=true;
					}
				:}| 
				DIM larghezza:l VIR altezza:a PV 
				{:
					if (a!= null && l!=null){
						int h=((Integer)a).intValue();
						int w=((Integer)l).intValue();
						
						varMap.put(new String("h"), (Integer)a);
						varMap.put(new String("w"), (Integer)l);
						parser.mappa=new SokoPieces[h][w];
						for(int k=0;k<h;k++)
							for(int j=0;j<w;j++)
								parser.mappa[k][j]=SokoPieces.floor;
						System.out.println("mappa.len="+parser.mappa.length+"-mappa[0].len="+parser.mappa[0].length);
					}
					else{
						parser.report_error("Errore dichiarazione dimensioni",null);
						parser.error=true;
					}
				:};
		
altezza	::=	HEIGHT UGUALE INT:i 
			{:
				RESULT=i;
			:}|
			HEIGHT UGUALE ID:i 
			{:
				if(varMap.containsKey(i) && varMap.get(i)!=null)
					RESULT=varMap.get(i);
				else
					RESULT = null;
			:} ;
			
larghezza ::=	WIDTH UGUALE INT:i 
				{:
					RESULT=i;
				:} |
				WIDTH UGUALE ID:i 
				{:
					if(varMap.containsKey((String)i) && varMap.get((String)i)!=null)
				 		RESULT=varMap.get((String)i);
					else
						RESULT = null;
				:};
		

numBlocchi ::=	NMOB INT:i PV {: parser.blocchiMobili=((Integer)i).intValue(); :} ;

definizioni ::=	elemento |
				definizioni elemento /* |
				error {: parser.report_error("defini errore",null); :}*/;

elemento ::=	VAR def PV 
				{:
					if (parser.error==true){
						parser.report_error("Errore dichiarazione",null);
						SemanticErrorNumber++;
						RESULT=null;
					}
				:}; // definizioni di varabili

def	::=	def VIR definizione |
		definizione  
		/*|
		}
		error {: parser.report_error("def errore",null); :}*/;

definizione ::= ID:i UGUALE INT:n  
				{: 
					System.out.println((String)i+"="+(Integer)n);
					if (varMap.containsKey((String)i)){
						parser.report_error("Ridefinizione variabile "+(String)i,null);
						parser.error=true;
					}
					else
						varMap.put((String)i, (Integer)n);
					

				:}|
				//ID:i1 UGUALE ID:i2 
				ID:i1 UGUALE myID:i2 
				{:
					System.out.println((String)i1+"="+(String)i2);
					if (varMap.containsKey((String)i1)){
						parser.report_error("Ridefinizione variabile "+(String)i1,null);
						parser.error=true;
					}
					else if(varMap.containsKey((String)i2) && varMap.get((String)i2)!=null)
						varMap.put((String)i1, varMap.get((String)i2) );
					else{
						parser.report_error("Undefined variable "+(String)i1,null);
						parser.error=true;
					}
				:}|
				ID :i
				{:
					System.out.println((String)i);
					if (varMap.containsKey((String)i)){
						parser.report_error("Ridefinizione variabile "+(String)i,null);
						parser.error=true;
					}
					else 
						varMap.put((String)i, null);
				:};

part	::=	corpo:c {: RESULT=c; :} |
			elemento:c {: RESULT=c; :} | 
			part:c elemento:s  {: if(c==null || s==null) c=null; RESULT=c; :}|
			part:c corpo:s {: if(c==null || s==null) c=null; RESULT=c;  :} /*|
			part error {: parser.report_error("part errore",null); :}*/;

corpo 	::=	cicloFor :f
			{:
				if (f!=null){
					MapAndResult mar=((AzioneFor)f).executeAction(varMap, parser.mappa);
					if (mar.result!=Result.OK){
						parser.error=true;
						parser.report_error(mar.ErrMsg,null);
						SemanticErrorNumber++;
						RESULT=null;
					}
					else{
						parser.mappa=mar.mappa;
						RESULT=1;
					}
				}
				else{
					parser.report_error("For cicle null",null);
					parser.error=true;
					RESULT=null;
				}
			:}|
			piazzamento:p 
			{: 
				if(p!=null){
					AzionePiazzamento ap=(AzionePiazzamento)p;
					MapAndResult mar=ap.executeAction(varMap, parser.mappa);
					if (mar.result!=Result.OK){
						parser.error=true;
						parser.report_error(mar.ErrMsg,null);
						SemanticErrorNumber++;
						RESULT=null;
					}
					else{
						parser.mappa=mar.mappa;
						RESULT=1;
					}
				}
				else{
					parser.report_error("Placement null",null);
					parser.error=true;
					RESULT=null;
				}
			:}|
			sezioneIF :si
			{:
				if(si!=null){
					AzioneIf ai=(AzioneIf)si;
					MapAndResult mar=ai.executeAction(varMap, parser.mappa);
					if (mar.result!=Result.OK){
						parser.error=true;
						parser.report_error(mar.ErrMsg,null);
						/**/System.out.println("errore if");
						SemanticErrorNumber++;
						RESULT=null;
					}
					else{
						parser.mappa=mar.mappa;
						RESULT=1;
					}
				}
				else{
					parser.report_error("If section null",null);
					parser.error=true;
					RESULT=null;
				}
			:}/*|
			error {: parser.report_error("corpo errore",null); :}*/;

cicloFor ::=	FOR TO assegnazione:as PV termine:t PV avanzamento:av TC contenuto:c END FOR PV 
				{:
					if (as==null || c==null || t==null){
						parser.report_error("For null",null);
						parser.error=true;
						RESULT = null;
					}
					else{
						AzioneFor azione=new AzioneFor();
						azione.var=((Assegnazione)as).id1;
						azione.start=element.traduci(((Assegnazione)as).id2, varMap);
						azione.cond=(Condizione)t;
						azione.incremento=(Boolean)av;
						azione.la=(ListaAzioni)c;
						RESULT = azione;
					}
				:}/*|
				FOR error {: parser.report_error("for errore",null); :}*/;

myID ::= ID:id {: RESULT=id; :} |
		WIDTH:id {: RESULT=id; :} |
		HEIGHT:id {: RESULT=id; :};
		
//assegnazione::=	ID:id1 UGUALE ID:id2 
assegnazione::=	ID:id1 UGUALE myID:id2 
				{:
					if (!varMap.containsKey(id1)){
						parser.report_error(Result.UndefinedVariable.name()+" "+id1,null);
						parser.error=true;
						RESULT=null;
					}
					else if (!varMap.containsKey(id2)){
						parser.report_error(Result.UndefinedVariable.name()+" "+id2,null);
						parser.error=true;
						RESULT=null;
					}
					else
						RESULT=new Assegnazione(id1, id2);
				:} |
				ID:id1 UGUALE INT:id2
				{:
					if (varMap.containsKey(id1) )
						RESULT=new Assegnazione(id1, id2);
					else{
						parser.report_error(Result.UndefinedVariable.name()+" "+id1,null);
						parser.error=true;
						RESULT=null;
					}
						
				:};

termine	::=	ID:id1 segno:s myID:id2
//termine	::=	ID:id1 segno:s ID:id2
			{:
				if(!varMap.containsKey((String)id1)){
					parser.report_error(Result.UndefinedVariable.name()+" "+id1,null);
					parser.error=true;
					RESULT=null;
				}
				else if(!varMap.containsKey((String)id2)){
					parser.report_error(Result.UndefinedVariable.name()+" "+id2,null);
					parser.error=true;
					RESULT=null;
				}
				else 
					RESULT=new Condizione(id1,id2,s);
	
			:}|
			ID:id1 segno:s INT:id2 
			{:
				if(!varMap.containsKey((String)id1)){
					parser.report_error(Result.UndefinedVariable.name(),null);
					parser.error=true;	
					RESULT=null;
				}
				else 
					RESULT=new Condizione(id1,id2,s);	
				
			:};

segno	::=	UGUALEUGUALE:s {: RESULT=s; :}|
			MAGUG :s {: RESULT=s; :}|
			MINUG :s {: RESULT=s; :}|
			MAG :s {: RESULT=s; :}| 
			MIN :s {: RESULT=s; :}|
			DIVERSO :s {: RESULT=s; :};
		
avanzamento ::=	ID INCR {: RESULT=new Boolean(true); :}|
				ID DECR {: RESULT=new Boolean(false); :};  		

contenuto ::=	piazzamento:p /*creo lista azioni */
				{:
					if(p==null){
						parser.report_error("Placement cont null",null);
						parser.error=true;
						RESULT=null;
					}
					else
						RESULT=new ListaAzioni(p);
				:}	| 
				cicloFor:f /*creo lista azioni */
				{:
					if(f==null){
						parser.report_error("For cont null",null);
						parser.error=true;
						RESULT=null;
					}
					else
						RESULT=new ListaAzioni(f);
				:}	|
				sezioneIF :i /*creo lista azioni */
				{:
					if(i==null){
						parser.report_error("If cont null",null);
						parser.error=true;
						RESULT=null;
					}
					else
						RESULT=new ListaAzioni(i);
				:}	|
				contenuto:c piazzamento:p /*aggiungo a lista azioni */
				{:
					if(p==null || c==null){
						parser.report_error("Cont or placement null",null);
						parser.error=true;
						RESULT=null;
					}
					else{
						((ListaAzioni)c).AddAzione(p);
						RESULT=c;
					}
				:}	|
				contenuto:c sezioneIF:i /*aggiungo a lista azioni */
				{:
					if(i==null || c==null){
						parser.report_error("Cont or if null",null);
						parser.error=true;
						RESULT=null;
					}
					else{
						((ListaAzioni)c).AddAzione(i);
						RESULT=c;
					}
				:}	|
				contenuto:c cicloFor:f /*aggiungo a lista azioni */
				{:
					if(f==null || c==null){
						parser.report_error("Cont or For null",null);
						parser.error=true;
						RESULT=null;
					}
					else{
						((ListaAzioni)c).AddAzione(f);
						RESULT=c;
					}
				:}	
			/*|
			error {: parser.report_error("contenuto errore",null); :}|
			contenuto error {: parser.report_error("contenuto errore",null); :}*/;
			
piazzamento ::=	tipo:t1 TO coppia:cp TC PV 
				{:
					if(cp!=null)
						((AzionePiazzamento)cp).setType(t1);						
					RESULT=cp;
				:} /*| 
				tipo TO coppia TC error {: parser.report_error("piazzamento errore",null); :}|
				tipo error {: parser.report_error("piazzamento errore",null); :}|
				tipo TO error TC PV {: parser.report_error("piazzamento errore",null); :}*/
				;
tipo ::=	MOB:t {: RESULT = t; :} |
			FISSI:t {: RESULT = t; :} |
			GOAL:t {: RESULT = t; :} | 
			SOKO:t {: RESULT = t; :} ;
		
coppia ::=	coordinata:t1 VIR coordinata:t2
			{:// System.out.println("_"+(String)t1+(String)t2);
				RESULT=new AzionePiazzamento(t1,t2);
			:} /*|
			coordinata error 
		 			{: parser.report_error("coppia errore",null); :}|
			error coordinata 
					{: parser.report_error("coppia errore",null); :}*/;
					
coordinata ::=	INT:t {: RESULT=t; :} |
				//ID:t
				myID:t
				{: 
					//System.out.println("_"+(String)t);
					//if(varMap.containsKey((String)t) && varMap.get((String)t)!=null)
						RESULT=t;
				:};
 

sezioneIF ::= IF TO termine:t TC contenuto:c END IF PV 
				{:
					if (t!=null && c!=null){
						AzioneIf ai = new AzioneIf();
						ai.cond=(Condizione)t;
						ai.la=(ListaAzioni)c;
						RESULT = ai;
					}
					else{
						parser.report_error("Term or cont null",null);
						parser.error=true;
						RESULT = null;
					}
						
				:}/*|
				IF error {: parser.report_error("sezione if errore",null); :}*/;



 




